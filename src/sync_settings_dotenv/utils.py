import importlib
import shutil
import sys
from datetime import UTC, datetime
from inspect import isclass
from pathlib import Path
from typing import Type

from pydantic_settings import BaseSettings
from rich import print as rprint


def import_class_from_module(module_path: str) -> Type[BaseSettings]:
    """Dynamically import a module and return the specified class."""
    import_path = "."
    sys.path.insert(0, import_path)
    module = importlib.import_module(module_path)
    for cls in module.__dict__.values():
        if isclass(cls) and issubclass(cls, BaseSettings) and cls.__module__.startswith(module_path):
            return cls

    raise ImportError(f"No BaseSettings subclass found in module {module_path}.")


def serialize_default_env_vars(settings_model: Type[BaseSettings]) -> dict[str, str]:
    env_dict = settings_model(_env_file="").model_dump(mode="json")
    return {key.upper(): (str(value) if value is not None else "") for key, value in env_dict.items()}


def generate_current_time() -> datetime:
    return datetime.now(UTC).replace(microsecond=0)


def generate_backup_env_file(env_path: Path, current_time: datetime | None = None) -> None:
    if not env_path.exists():
        return

    current_time = current_time or generate_current_time()
    time_string = current_time.strftime("%Y%m%d_%H%M%SZ")
    backup_path = env_path.with_suffix(f"{env_path.suffix}.backup.{time_string}")
    shutil.copy(env_path, backup_path)
    rprint(f"[blue]Info:[/blue] Generated backup file at {backup_path}")


def generate_dotenv_file(env_path: Path, env_vars: dict[str, str | None]) -> None:
    current_time = generate_current_time()
    generate_backup_env_file(env_path, current_time)
    with env_path.open("w", encoding="utf-8") as file:
        file.write(f"# Generated by sync-settings-dotenv at {current_time}\n")
        for key, value in env_vars.items():
            line = f"{key}={value}\n"
            file.write(line)
