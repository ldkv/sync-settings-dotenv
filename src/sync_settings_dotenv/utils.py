import importlib
import shutil
import sys
from datetime import UTC, datetime
from inspect import isclass
from pathlib import Path
from typing import Type

from dotenv import dotenv_values
from pydantic_settings import BaseSettings
from rich import print as rprint

SUPPORTED_MODELS = (BaseSettings,)
REQUIRED_PLACEHOLDER = "<required>"

EnvVarsDict = dict[str, str | None]


def generate_source_env_vars(module_path: str) -> EnvVarsDict:
    if Path(module_path).is_file():
        return dotenv_values(module_path)

    settings_model = import_class_from_module(module_path)
    return generate_env_vars_from_class(settings_model)


def import_class_from_module(module_path: str) -> Type[BaseSettings]:
    import_path = "."
    sys.path.insert(0, import_path)
    module = importlib.import_module(module_path)
    for cls in module.__dict__.values():
        if isclass(cls) and issubclass(cls, SUPPORTED_MODELS) and cls.__module__.startswith(module_path):
            return cls

    raise ImportError(f"No BaseSettings subclass found in module {module_path}.")


def generate_env_vars_from_class(settings_model: Type[BaseSettings]) -> EnvVarsDict:
    default_env_vars = {}
    for field_name, field_info in settings_model.model_fields.items():
        default_value = REQUIRED_PLACEHOLDER
        if not field_info.is_required():
            default_value = field_info.get_default(call_default_factory=True)
        default_env_vars[field_name] = default_value

    # Using model_construct to avoid validation for required fields
    default_instance = settings_model.model_construct(**default_env_vars)
    # Using mode="json" to get serialized values
    return default_instance.model_dump(mode="json")


def generate_current_time() -> datetime:
    return datetime.now(UTC).replace(microsecond=0)


def generate_backup_env_file(env_path: Path, current_time: datetime | None = None) -> None:
    if not env_path.exists():
        return

    current_time = current_time or generate_current_time()
    time_string = current_time.strftime("%Y%m%d_%H%M%SZ")
    backup_path = env_path.with_suffix(f"{env_path.suffix}.backup.{time_string}")
    shutil.copy(env_path, backup_path)
    rprint(f"[blue]Info:[/blue] Generated backup file at {backup_path}")


def generate_dotenv_file(env_path: Path, env_vars: EnvVarsDict, with_header: bool = True) -> None:
    current_time = generate_current_time()
    generate_backup_env_file(env_path, current_time)
    with env_path.open("w", encoding="utf-8") as file:
        if with_header:
            file.write(f"# Generated by sync-settings-dotenv at {current_time}\n")
        for key, value in env_vars.items():
            line = f"{key}={value}\n"
            file.write(line)


def resolve_env_vars_combination(
    src_env_vars: EnvVarsDict,
    dst_env_vars: EnvVarsDict,
    overwrite_values: bool = False,
    exact_match: bool = False,
) -> EnvVarsDict:
    combined_env_vars = {key.upper(): value for key, value in dst_env_vars.items()}
    for field_name, default_value in src_env_vars.items():
        field_name_upper = field_name.upper()
        if exact_match or overwrite_values or field_name_upper not in combined_env_vars:
            combined_env_vars[field_name_upper] = str(default_value)

    return combined_env_vars
